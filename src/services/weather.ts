/**
 * Weather Service with IP-based Geolocation
 * Provides weather data for the user's location
 */

interface OpenWeatherAPIForecastItem {
  dt: number
  main: {
    temp: number
    feels_like: number
    temp_min: number
    temp_max: number
    pressure: number
    humidity: number
  }
  weather: Array<{
    id: number
    main: string
    description: string
    icon: string
  }>
  wind: {
    speed: number
    deg: number
  }
}

interface ForecastDayData {
  date: string
  temps: number[]
  weather: { main: string; description: string; icon: string }
}

export interface WeatherData {
  location: {
    city: string
    country: string
    latitude: number
    longitude: number
  }
  current: {
    temperature: number
    feels_like: number
    humidity: number
    pressure: number
    visibility: number
    weather: {
      main: string
      description: string
      icon: string
    }
    wind: {
      speed: number
      direction: number
    }
  }
  forecast: Array<{
    date: string
    temp_max: number
    temp_min: number
    weather: {
      main: string
      description: string
      icon: string
    }
  }>
  timestamp: Date
}

interface LocationData {
  ip: string
  city: string
  region: string
  country: string
  latitude: number
  longitude: number
  timezone: string
}

class WeatherService {
  private apiKey: string | null = null
  private lastWeatherUpdate: Date | null = null
  private cachedWeather: WeatherData | null = null
  private cacheTimeout = 10 * 60 * 1000 // 10 minutes

  async initialize(): Promise<void> {
    // Get API key from environment or backend
    this.apiKey = import.meta.env.VITE_OPENWEATHER_API_KEY || 
                  await this.getSecureApiKey('weather')
                  
    // Initialize Monica AI integration for weather interpretations
    this.monicaApiKey = import.meta.env.VITE_MONICA_API_KEY || 
                       await this.getSecureApiKey('monica')
  }
  
  private monicaApiKey: string | null = null

  async getCurrentWeather(): Promise<WeatherData> {
    // Check cache first
    if (this.cachedWeather && this.lastWeatherUpdate) {
      const timeSinceUpdate = Date.now() - this.lastWeatherUpdate.getTime()
      if (timeSinceUpdate < this.cacheTimeout) {
        return this.cachedWeather
      }
    }

    try {
      // Get user location by IP
      const location = await this.getUserLocationByIP()
      
      // Fetch weather data
      const weatherData = await this.fetchWeatherData(location.latitude, location.longitude)
      
      // Cache the result
      this.cachedWeather = weatherData
      this.lastWeatherUpdate = new Date()
      
      return weatherData
    } catch (error) {
      console.error('Weather service error:', error)
      throw new Error('Failed to fetch weather data')
    }
  }

  private async getUserLocationByIP(): Promise<LocationData> {
    try {
      // Try multiple IP geolocation services for reliability
      const services = [
        () => this.fetchFromIPInfo(),
        () => this.fetchFromIPAPI(),
        () => this.fetchFromIPGeolocation()
      ]

      for (const service of services) {
        try {
          const location = await service()
          if (location.latitude && location.longitude) {
            return location
          }
        } catch (serviceError) {
          console.warn('IP service failed, trying next:', serviceError)
          continue
        }
      }

      throw new Error('All IP geolocation services failed')
    } catch (error) {
      // Fallback to default location (Taipei)
      console.warn('Using fallback location:', error)
      return {
        ip: 'unknown',
        city: 'Taipei',
        region: 'Taiwan',
        country: 'TW',
        latitude: 25.0330,
        longitude: 121.5654,
        timezone: 'Asia/Taipei'
      }
    }
  }

  private async fetchFromIPInfo(): Promise<LocationData> {
    const response = await fetch('https://ipinfo.io/json', {
      headers: {
        'Accept': 'application/json'
      }
    })
    
    if (!response.ok) throw new Error('IPInfo API failed')
    
    const data = await response.json()
    const [lat, lon] = data.loc.split(',')
    
    return {
      ip: data.ip,
      city: data.city,
      region: data.region,
      country: data.country,
      latitude: parseFloat(lat),
      longitude: parseFloat(lon),
      timezone: data.timezone
    }
  }

  private async fetchFromIPAPI(): Promise<LocationData> {
    const response = await fetch('http://ip-api.com/json/', {
      headers: {
        'Accept': 'application/json'
      }
    })
    
    if (!response.ok) throw new Error('IP-API failed')
    
    const data = await response.json()
    
    if (data.status !== 'success') {
      throw new Error('IP-API returned error status')
    }
    
    return {
      ip: data.query,
      city: data.city,
      region: data.regionName,
      country: data.countryCode,
      latitude: data.lat,
      longitude: data.lon,
      timezone: data.timezone
    }
  }

  private async fetchFromIPGeolocation(): Promise<LocationData> {
    // This would require an API key for ipgeolocation.io
    const apiKey = import.meta.env.VITE_IPGEOLOCATION_API_KEY
    if (!apiKey) throw new Error('No IP Geolocation API key')

    const response = await fetch(`https://api.ipgeolocation.io/ipgeo?apiKey=${apiKey}`, {
      headers: {
        'Accept': 'application/json'
      }
    })
    
    if (!response.ok) throw new Error('IP Geolocation API failed')
    
    const data = await response.json()
    
    return {
      ip: data.ip,
      city: data.city,
      region: data.state_prov,
      country: data.country_code2,
      latitude: parseFloat(data.latitude),
      longitude: parseFloat(data.longitude),
      timezone: data.time_zone.name
    }
  }

  private async fetchWeatherData(lat: number, lon: number): Promise<WeatherData> {
    if (!this.apiKey) {
      throw new Error('Weather API key not configured')
    }

    // Current weather
    const currentResponse = await fetch(
      `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${this.apiKey}&units=metric`
    )
    
    if (!currentResponse.ok) {
      throw new Error(`OpenWeatherMap API error: ${currentResponse.status}`)
    }
    
    const currentData = await currentResponse.json()

    // 5-day forecast
    const forecastResponse = await fetch(
      `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${this.apiKey}&units=metric`
    )
    
    if (!forecastResponse.ok) {
      throw new Error(`OpenWeatherMap Forecast API error: ${forecastResponse.status}`)
    }
    
    const forecastData = await forecastResponse.json()

    // Process forecast data (get daily data)
    const dailyForecast = this.processForecastData(forecastData.list)

    return {
      location: {
        city: currentData.name,
        country: currentData.sys.country,
        latitude: lat,
        longitude: lon
      },
      current: {
        temperature: Math.round(currentData.main.temp),
        feels_like: Math.round(currentData.main.feels_like),
        humidity: currentData.main.humidity,
        pressure: currentData.main.pressure,
        visibility: Math.round((currentData.visibility || 10000) / 1000),
        weather: {
          main: currentData.weather[0].main,
          description: currentData.weather[0].description,
          icon: currentData.weather[0].icon
        },
        wind: {
          speed: currentData.wind?.speed || 0,
          direction: currentData.wind?.deg || 0
        }
      },
      forecast: dailyForecast,
      timestamp: new Date()
    }
  }

  private processForecastData(forecastList: OpenWeatherAPIForecastItem[]): WeatherData['forecast'] {
    const dailyData = new Map<string, ForecastDayData>()
    
    forecastList.forEach(item => {
      const date = new Date(item.dt * 1000).toDateString()
      
      if (!dailyData.has(date)) {
        dailyData.set(date, {
          date,
          temps: [item.main.temp],
          weather: item.weather[0]
        })
      } else {
        dailyData.get(date)!.temps.push(item.main.temp)
      }
    })

    return Array.from(dailyData.values())
      .slice(1, 6) // Next 5 days
      .map(day => ({
        date: day.date,
        temp_max: Math.round(Math.max(...day.temps)),
        temp_min: Math.round(Math.min(...day.temps)),
        weather: {
          main: day.weather.main,
          description: day.weather.description,
          icon: day.weather.icon
        }
      }))
  }

  private async getSecureApiKey(service: 'weather' | 'news' | 'monica'): Promise<string> {
    try {
      const response = await fetch(`/api/keys/${service}`, {
        credentials: 'include'
      })
      
      if (!response.ok) throw new Error('Failed to get API key')
      
      const data = await response.json()
      return data.apiKey
    } catch (error) {
      console.warn(`Could not get secure ${service} API key:`, error)
      return ''
    }
  }

  // Utility method to get weather emoji
  getWeatherEmoji(weatherMain: string): string {
    const emojiMap: Record<string, string> = {
      'Clear': '‚òÄÔ∏è',
      'Clouds': '‚òÅÔ∏è',
      'Rain': 'üåßÔ∏è',
      'Drizzle': 'üå¶Ô∏è',
      'Thunderstorm': '‚õàÔ∏è',
      'Snow': '‚ùÑÔ∏è',
      'Mist': 'üå´Ô∏è',
      'Fog': 'üå´Ô∏è',
      'Haze': 'üò∂‚Äçüå´Ô∏è'
    }
    return emojiMap[weatherMain] || 'üå§Ô∏è'
  }

  // Get AI-enhanced mystical weather interpretation
  async getMysticalInterpretation(weatherData: WeatherData): Promise<string> {
    if (this.monicaApiKey) {
      try {
        return await this.getMonicaWeatherInterpretation(weatherData)
      } catch (error) {
        console.warn('Monica weather interpretation failed, using fallback:', error)
      }
    }
    
    // Fallback to basic interpretation
    const { weather, temperature } = weatherData.current
    const interpretations: Record<string, string> = {
      'Clear': 'ÈôΩÂÖâÊôÆÁÖßÔºåÂÆáÂÆôËÉΩÈáèÂÖÖÊ≤õÔºåÈÅ©ÂêàÈÄ≤Ë°åÁ©çÊ•µÁöÑÂç†ÂçúÂíåÈ°ØÂåñ',
      'Clouds': 'Èõ≤ÈúßÁπöÁπûÔºåÈÅ©ÂêàÂÖßÁúÅÂíåÈùàÊÄßÊÄùËÄÉÔºåÈö±ËóèÁöÑÊô∫ÊÖßÂ∞áË¢´Êè≠Á§∫',
      'Rain': 'Èõ®Ê∞¥Ê∑®ÂåñÂ§ßÂú∞ÔºåÊÉÖÊÑüËÉΩÈáèÊµÅÂãïÔºåÈÅ©ÂêàËôïÁêÜÊÑüÊÉÖÂíåÁôÇÁôíË≠∞È°å',
      'Thunderstorm': 'Èõ∑Èõª‰∫§Âä†ÔºåÂº∑Â§ßÁöÑËΩâÂåñËÉΩÈáèÔºåÈáçÂ§ßËÆäÈù©Âç≥Â∞á‰æÜËá®',
      'Snow': 'Èõ™Ëä±Á¥õÈ£õÔºåÂØßÈùúËàáÁ¥îÊ∑®ÔºåÈÅ©ÂêàÂÜ•ÊÉ≥ÂíåÊ∑±Â∫¶ÈùàÊÄßÈÄ£Êé•',
      'Mist': 'ËñÑÈúßÁ±†ÁΩ©ÔºåÁ•ûÁßòËÉΩÈáèÊøÉÂéöÔºåÁõ¥Ë¶∫ÂäõÂ∞áÂæóÂà∞Â¢ûÂº∑'
    }

    const tempInterpretation = temperature > 25 ? 'ÁÇéÁÜ±ÁöÑËÉΩÈáèÊøÄÁôºË°åÂãïÂäõ' :
                             temperature > 15 ? 'Ê∫´ÂíåÁöÑËÉΩÈáèÂπ≥Ë°°Ë∫´ÂøÉ' :
                             'Ê∏ÖÊ∂ºÁöÑËÉΩÈáèËÆìÊÄùÁ∑íÊõ¥Âä†Ê∏ÖÊòé'

    return `${interpretations[weather.main] || 'Â§©Ê∞£ËÆäÂåñÊöóÁ§∫ËëóËÉΩÈáèÁöÑÊµÅÂãï'}„ÄÇ${tempInterpretation}„ÄÇ`
  }

  // Monica AI weather interpretation
  private async getMonicaWeatherInterpretation(weatherData: WeatherData): Promise<string> {
    const prompt = `‰Ω†ÊòØ‰∏Ä‰ΩçÁµêÂêàÊ∞£Ë±°Â≠∏ËàáÂ°îÁæÖÂç†ÂçúÁöÑÁ•ûÁßòÂ≠∏Â§ßÂ∏´„ÄÇË´ãÊ†πÊìö‰ª•‰∏ãÂ§©Ê∞£Êï∏ÊìöÊèê‰æõÊ∑±Â∫¶ÁöÑÈùàÊÄßËß£ËÆÄÔºö

üå§Ô∏è Â§©Ê∞£ÁãÄÊ≥ÅÔºö${weatherData.current.weather.description}
üå°Ô∏è Ê∫´Â∫¶Ôºö${weatherData.current.temperature}¬∞C (È´îÊÑü ${weatherData.current.feels_like}¬∞C)
üíß ÊøïÂ∫¶Ôºö${weatherData.current.humidity}%
üå™Ô∏è È¢®ÈÄüÔºö${weatherData.current.wind.speed} m/s
üëÅÔ∏è ËÉΩË¶ãÂ∫¶Ôºö${weatherData.current.visibility} km
üìç Âú∞ÈªûÔºö${weatherData.location.city}, ${weatherData.location.country}

Ë´ãÊèê‰æõ‰∏ÄÂÄã80-120Â≠óÁöÑÁ•ûÁßòÂ≠∏Ëß£ËÆÄÔºåÂÖßÂÆπÂåÖÊã¨Ôºö
1. Áï∂ÂâçÂ§©Ë±°ÁöÑÈùàÊÄßÊÑèÁæ©
2. Â∞çÂ°îÁæÖÂç†ÂçúÊ¥ªÂãïÁöÑÂΩ±Èüø
3. ÂÄã‰∫∫ËÉΩÈáèÁãÄÊÖãÁöÑÂª∫Ë≠∞
4. ‰ªäÊó•ÂÆáÂÆôËÉΩÈáèÁöÑÊµÅÂãïÊñπÂêë

Ë´ãÁî®ÂÖÖÊªøË©©ÊÑè‰ΩÜÂØ¶Áî®ÁöÑ‰∏≠ÊñáÂõûÁ≠îÔºåËûçÂêàÂè§ËÄÅÊô∫ÊÖßËàáÁèæ‰ª£ÁêÜËß£„ÄÇ`

    const response = await fetch('https://openapi.monica.im/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.monicaApiKey}`
      },
      body: JSON.stringify({
        model: 'claude-3-5-sonnet-20241022',
        messages: [
          {
            role: 'system',
            content: '‰Ω†ÊòØÂ§úÁ•ûÂ°îÁæÖÁöÑÈ¶ñÂ∏≠Ê∞£Ë±°ÈùàÊÄßÂ∞éÂ∏´ÔºåÊìÖÈï∑Â∞áÂ§©Ê∞£ÁèæË±°ËàáÂ°îÁæÖËÉΩÈáèÁõ∏ÁµêÂêàÔºåÊèê‰æõÊ∑±ÈÇÉËÄåÂØ¶Áî®ÁöÑÈùàÊÄßÊåáÂºï„ÄÇ'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.8,
        max_tokens: 300
      })
    })

    if (!response.ok) {
      throw new Error(`Monica API Error: ${response.status}`)
    }

    const data = await response.json()
    return data.choices[0].message.content
  }
}

export const weatherService = new WeatherService()